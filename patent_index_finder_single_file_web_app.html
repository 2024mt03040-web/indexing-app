<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Patent Index Finder (Client‑Side)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --card: #121824;
      --muted: #8892a6;
      --text: #eef2ff;
      --accent: #80ffd3;
      --accent2: #8ab4ff;
      --danger: #ff9da4;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 80% -20%, #1a2335 0%, #0b0f14 60%) fixed;
      color: var(--text);
    }
    header { padding: 28px 18px 12px; text-align: center; }
    header h1 { margin: 0; font-size: 28px; letter-spacing: .2px; }
    header p { margin: 6px auto 0; color: var(--muted); max-width: 820px; }

    .wrap { max-width: 1100px; margin: 0 auto; padding: 18px; }
    .grid { display: grid; grid-template-columns: 1.25fr .75fr; gap: 16px; align-items: start; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
            border: 1px solid rgba(255,255,255,.08); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35);
            overflow: hidden; }
    .card h2 { margin: 0; padding: 14px 16px; font-size: 18px; border-bottom: 1px solid rgba(255,255,255,.08);
               background: linear-gradient(90deg, rgba(128,255,211,.12), rgba(138,180,255,.12)); }
    .card .body { padding: 14px 16px 18px; }

    label { display:block; font-weight:600; margin: 10px 0 6px; }

    .uploader { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    input[type="file"], select, textarea, input[type="text"] {
      width: 100%; border: 1px solid rgba(255,255,255,.12); background: #0f1522; color: var(--text);
      padding: 10px 12px; border-radius: 10px; outline: none; box-shadow: inset 0 0 0 1px transparent; transition: .15s;
    }
    select { cursor: pointer; }
    textarea { min-height: 140px; resize: vertical; }

    .row { display:flex; gap: 10px; }
    .row > * { flex: 1; }

    .btn {
      appearance: none; border: none; cursor: pointer; font-weight: 700; letter-spacing:.2px;
      padding: 10px 14px; border-radius: 12px; color: #061013; background: var(--accent);
      transition: transform .06s ease, box-shadow .2s ease, filter .3s ease; box-shadow: 0 6px 18px rgba(128,255,211,.25);
    }
    .btn:hover { transform: translateY(-1px); }
    .btn.secondary { background: #1b2436; color: var(--text); box-shadow: none; border: 1px solid rgba(255,255,255,.1); }

    .muted { color: var(--muted); }
    .kpi { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .chip { padding: 6px 10px; border-radius: 999px; border: 1px dashed rgba(255,255,255,.2); font-size: 13px; }

    .result { background:#0c121f; border:1px solid rgba(128,255,211,.35); border-radius:14px; padding:12px; margin:10px 0; }
    .result h3 { margin: 0 0 6px; font-size: 16px; }

    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
           background: #0b101a; color: #b9d0ff; border-radius: 12px; padding: 10px; max-height: 260px; overflow: auto;
           border: 1px solid rgba(255,255,255,.1); }
    .hint { font-size: 13px; margin-top: 6px; color: var(--muted); }

    footer { text-align:center; padding: 20px; color: var(--muted); font-size: 13px; }
  </style>
  <!-- PDF.js via CDN -->
  <script src="https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.min.js"></script>
  <script>
    // Configure worker (uses same CDN version)
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.worker.min.js";
  </script>
</head>
<body>
  <header>
    <h1>Patent Index Finder (Free • Client‑Side)</h1>
    <p>Upload a USPTO PDF (application or granted). Paste an excerpt. This tool estimates the <b>paragraph</b> for US applications (A1) and <b>column:line</b> for granted US patents. All processing runs locally in your browser.</p>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- Left: Controls -->
      <section class="card">
        <h2>1) Upload & Configure</h2>
        <div class="body">
          <div class="uploader">
            <input id="pdfFile" type="file" accept="application/pdf" />
          </div>
          <div class="row">
            <div>
              <label for="docType">Document Type</label>
              <select id="docType">
                <option value="auto">Auto‑detect (try this first)</option>
                <option value="app">US Application (A1) → [0001] paragraphs</option>
                <option value="grant">US Granted Patent → column:line</option>
              </select>
            </div>
            <div>
              <label for="pageScope">Page Scope (optional)</label>
              <input id="pageScope" type="text" placeholder="e.g., 1-5 or 3,6,9"/>
              <div class="hint">For large PDFs, limit pages to speed up.</div>
            </div>
          </div>

          <label for="excerpt">2) Paste Excerpt</label>
          <textarea id="excerpt" placeholder="Paste the exact text snippet you want to locate..."></textarea>

          <div class="row" style="margin-top:10px;">
            <button id="btnIndex" class="btn">Find Index</button>
            <button id="btnReset" class="btn secondary">Reset</button>
          </div>

          <div class="kpi">
            <span class="chip" id="chipPages">Pages: —</span>
            <span class="chip" id="chipStatus">Status: idle</span>
            <span class="chip" id="chipType">Detected: —</span>
          </div>
        </div>
      </section>

      <!-- Right: Results -->
      <section class="card">
        <h2>Results</h2>
        <div class="body">
          <div id="results"></div>
          <div id="explain" class="hint"></div>
        </div>
      </section>

      <!-- Full width: logs -->
      <section class="card" style="grid-column: 1 / -1;">
        <h2>Debug Log</h2>
        <div class="body">
          <pre id="log" class="log"></pre>
        </div>
      </section>

    </div>
  </div>

  <footer>
    Built for educational use. Accuracy depends on PDF text layer quality and layout. No data leaves your device.
  </footer>

  <script>
    // -------------------------- Utility helpers ---------------------------
    const $ = (sel) => document.querySelector(sel);
    const logEl = $('#log');
    function log(msg) { logEl.textContent += (msg + "\n"); logEl.scrollTop = logEl.scrollHeight; }
    function setStatus(text) { $('#chipStatus').textContent = 'Status: ' + text; }
    function setDetected(text) { $('#chipType').textContent = 'Detected: ' + text; }

    function parsePageScope(scopeStr, pageCount) {
      if (!scopeStr) return null; // all pages
      const parts = scopeStr.split(',').map(s => s.trim()).filter(Boolean);
      const set = new Set();
      for (const p of parts) {
        if (p.includes('-')) {
          const [a,b] = p.split('-').map(n=>parseInt(n,10));
          if (!isNaN(a) && !isNaN(b)) {
            for (let i=Math.max(1,a); i<=Math.min(pageCount,b); i++) set.add(i);
          }
        } else {
          const n = parseInt(p,10);
          if (!isNaN(n) && n>=1 && n<=pageCount) set.add(n);
        }
      }
      return [...set].sort((x,y)=>x-y);
    }

    function normalize(str){
      return str.replace(/[\u2018\u2019]/g, "'")
                .replace(/[\u201C\u201D]/g, '"')
                .replace(/\s+/g,' ') // collapse whitespace
                .trim();
    }

    function similarity(a,b){
      // Simple token overlap similarity for multi-match ranking
      const ta = new Set(normalize(a).toLowerCase().split(' '));
      const tb = new Set(normalize(b).toLowerCase().split(' '));
      let inter=0; for (const t of ta) if (tb.has(t)) inter++;
      return inter / Math.max(1, Math.min(ta.size, tb.size));
    }

    function groupByY(items, tol=2){
      // items: [{str, x, y}]
      const rows = [];
      const sorted = items.slice().sort((a,b)=> a.y===b.y? a.x-b.x : a.y - b.y);
      for (const it of sorted){
        let row = rows.find(r => Math.abs(r.y - it.y) <= tol);
        if (!row) { row = { y: it.y, items: [] }; rows.push(row); }
        row.items.push(it);
      }
      return rows.map(r=>({ y:r.y, text: r.items.map(i=>i.str).join(' '), items: r.items.sort((a,b)=>a.x-b.x) }));
    }

    function leftOrRightColumn(x, pageWidth){
      return (x < pageWidth/2) ? 1 : 2;
    }

    function isLikelyLineNumberToken(tok){
      // Short purely numeric (1–3 digits) near margins often the line number
      return /^[0-9]{1,3}$/.test(tok.str) && (tok.x < 60 || tok.x > tok.pageWidth-60);
    }

    // -------------------------- Core indexing logic ---------------------------
    async function extractPages(pdf, scope){
      const pageCount = pdf.numPages;
      const pages = [];
      const chosen = scope && scope.length ? scope : Array.from({length:pageCount}, (_,i)=>i+1);
      for (const p of chosen){
        const page = await pdf.getPage(p);
        const viewport = page.getViewport({ scale: 1.0 });
        const tc = await page.getTextContent();
        const tokens = tc.items.map(it=>{
          const tx = pdfjsLib.Util.transform(viewport.transform, it.transform);
          const x = tx[4], y = tx[5];
          return {
            str: (it.str || ''), x, y, fontSize: Math.abs(it.transform[0]) || 10, page: p, pageWidth: viewport.width, pageHeight: viewport.height
          };
        }).filter(t=>t.str && t.str.trim());
        pages.push({ page: p, width: viewport.width, height: viewport.height, tokens });
      }
      return { pageCount, pages };
    }

    function detectDocType(allText){
      const t = allText.toLowerCase();
      // Heuristics
      if (/\[[0-9]{4}\]/.test(allText)) return 'app'; // paragraphs like [0001]
      if (/(united states patent)/i.test(allText) && /column/i.test(allText)) return 'grant';
      return 'unknown';
    }

    function buildApplicationParagraphIndex(pages){
      // Build a big string with paragraph markers, and map character offsets → [paraNo, page]
      const paraRegex = /\[([0-9]{4})\]/g; // captures [0001]
      const perPageText = pages.map(pg => pg.tokens.map(t=>t.str).join(' '));
      const full = perPageText.join('\n\n');

      // Find paragraph markers with page mapping
      const pageOffsets = [];
      let cum = 0;
      for (const txt of perPageText){ pageOffsets.push(cum); cum += txt.length + 2; }

      const paras = [];
      let m;
      while ((m = paraRegex.exec(full))){
        const idx = m.index;
        const para = m[1];
        // determine page by last pageOffset <= idx
        let page = 1;
        for (let i=0;i<pageOffsets.length;i++){
          if (pageOffsets[i] <= idx) page = i+1; else break;
        }
        paras.push({ index: idx, para, page });
      }
      return { full, paras, pageOffsets };
    }

    function locateExcerptInApplication(excerpt, paragraphIndex){
      const normFull = normalize(paragraphIndex.full);
      const normEx = normalize(excerpt);
      const pos = normFull.indexOf(normEx);
      if (pos === -1) return null;
      // find nearest preceding paragraph marker
      let para = null, page = 1;
      for (const p of paragraphIndex.paras){
        const idxInNorm = normalize(paragraphIndex.full.slice(0, p.index)).length;
        if (idxInNorm <= pos) { para = p.para; page = p.page; } else break;
      }
      return { paragraph: para ? `[${para}]` : 'unknown', page, matchConfidence: 1.0 };
    }

    function buildGrantLineModel(pages){
      // For each page: group tokens into visual rows; detect line numbers and columns
      const model = [];
      for (const pg of pages){
        const rows = groupByY(pg.tokens, 2);
        const lines = rows.map(r=>{
          // Determine column by average x of non‑number tokens
          const contentTokens = r.items.filter(it=>!isLikelyLineNumberToken(it));
          const avgX = contentTokens.length ? contentTokens.reduce((a,b)=>a+b.x,0)/contentTokens.length : (r.items[0]?.x||0);
          const column = leftOrRightColumn(avgX, pg.width);
          const lineNumTok = r.items.find(isLikelyLineNumberToken);
          const lineNumber = lineNumTok ? parseInt(lineNumTok.str, 10) : null;
          return {
            page: pg.page, y: r.y, text: r.text, column, lineNumber, pageWidth: pg.width
          };
        }).filter(l => /[A-Za-z0-9]/.test(l.text)); // drop empty artifacts
        model.push({ page: pg.page, width: pg.width, lines });
      }
      return model;
    }

    function locateExcerptInGrant(excerpt, grantModel){
      const normEx = normalize(excerpt).toLowerCase();
      const candidates = [];

      for (const pm of grantModel){
        for (let i=0; i<pm.lines.length; i++){
          const L = pm.lines[i];
          const normLine = normalize(L.text).toLowerCase();
          if (normLine.includes(normEx)){
            candidates.push({ page: pm.page, column: L.column, line: L.lineNumber ?? (i+1), score: 1.0 });
          }
          // Also try 3-line windows to catch breaks
          if (i+2 < pm.lines.length){
            const block = [pm.lines[i].text, pm.lines[i+1].text, pm.lines[i+2].text].join(' ');
            if (normalize(block).toLowerCase().includes(normEx)){
              const first = pm.lines[i];
              candidates.push({ page: pm.page, column: first.column, line: first.lineNumber ?? (i+1), score: 0.8 });
            }
          }
        }
      }
      // Prefer exact single‑line matches with a line number
      candidates.sort((a,b)=> (b.score - a.score) || (Number.isInteger(b.line) - Number.isInteger(a.line)) );
      return candidates[0] || null;
    }

    // ------------------------------ UI wiring -------------------------------
    let pdfDoc = null, pdfMeta = null;

    $('#btnReset').addEventListener('click', () => {
      $('#pdfFile').value = '';
      $('#excerpt').value = '';
      $('#results').innerHTML = '';
      $('#explain').textContent = '';
      $('#chipPages').textContent = 'Pages: —';
      setStatus('idle'); setDetected('—');
      logEl.textContent = '';
      pdfDoc = null; pdfMeta = null;
    });

    $('#pdfFile').addEventListener('change', async (e) => {
      const f = e.target.files[0];
      if (!f) return;
      setStatus('loading PDF'); log('Reading file…');
      const buf = await f.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument({ data: buf }).promise;
      $('#chipPages').textContent = `Pages: ${pdfDoc.numPages}`;
      setStatus('loaded');
      log('PDF loaded. You can now paste an excerpt and click "Find Index".');
    });

    $('#btnIndex').addEventListener('click', async () => {
      if (!pdfDoc) { alert('Please upload a PDF first.'); return; }
      const excerpt = $('#excerpt').value.trim();
      if (!excerpt) { alert('Paste an excerpt to locate.'); return; }

      const pageScope = parsePageScope($('#pageScope').value, pdfDoc.numPages);
      setStatus('extracting'); log('Extracting text…');
      const { pageCount, pages } = await extractPages(pdfDoc, pageScope);

      // Build a concatenated text for type detection
      const allText = pages.map(pg => pg.tokens.map(t=>t.str).join(' ')).join('\n');
      let chosenType = $('#docType').value;
      const auto = (chosenType === 'auto');
      if (auto){
        const detected = detectDocType(allText);
        setDetected(detected);
        chosenType = (detected === 'unknown') ? 'app' : detected; // bias toward app if unknown
      } else {
        setDetected(chosenType);
      }

      let html = '';
      let explanation = '';

      try {
        if (chosenType === 'app'){
          const idx = buildApplicationParagraphIndex(pages);
          const res = locateExcerptInApplication(excerpt, idx);
          if (res){
            html += renderResult(`Paragraph: <b>${res.paragraph}</b>`, [
              ['Estimated Page', res.page],
              ['Match Confidence', `${(res.matchConfidence*100)|0}%`]
            ], 'Application paragraphs are identified by bracketed numbers like [0001]. We locate your excerpt and map it to the nearest preceding paragraph marker.');
          } else {
            html += renderMiss();
          }
        } else if (chosenType === 'grant'){
          const model = buildGrantLineModel(pages);
          const res = locateExcerptInGrant(excerpt, model);
          if (res){
            html += renderResult(`Column:Line → <b>${res.column}:${res.line}</b>`, [
              ['Page', res.page],
              ['Heuristic Confidence', `${Math.round(res.score*100)}%`]
            ], 'We infer columns from token X positions and line numbers from margin numerals. If explicit line numerals are absent in the PDF text layer, we estimate line order.');
          } else {
            html += renderMiss();
          }
        } else {
          html += `<div class="result"><h3>Could not auto‑detect</h3><div class="muted">Try selecting the type manually and run again.</div></div>`;
        }
      } catch (err){
        log('Error: ' + err.message);
        html += `<div class="result"><h3 style="color:var(--danger)">Error while indexing</h3><div>${err.message}</div></div>`;
      }

      $('#results').innerHTML = html;
      setStatus('done');
    });

    function renderResult(title, facts, note){
      const rows = facts.map(([k,v]) => `<div><span class="muted">${k}:</span> ${v}</div>`).join('');
      return `<div class="result"><h3>${title}</h3>${rows}${note?`<div class="hint" style="margin-top:6px">${note}</div>`:''}</div>`;
    }

    function renderMiss(){
      return `<div class="result"><h3>No exact hit</h3><div class="muted">We couldn’t confidently align your excerpt. Try a longer snippet, reduce punctuation, or limit the page scope.</div></div>`;
    }
  </script>
</body>
</html>
